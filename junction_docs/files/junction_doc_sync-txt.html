<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">

<html><head><title>Synchronization</title><link rel="stylesheet" type="text/css" href="../styles/main.css"><script language=JavaScript src="../javascript/main.js"></script></head><body class=UnframedPage onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version 1.35 -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org -->

<table border=0 cellspacing=0 cellpadding=0 width=100%><tr><td class=MenuSection valign=top><!--START_ND_MENU--><div class=MEntry><div class=MFile><a href="junction_doc_about-txt.html">About TrimPath Junction</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_run-txt.html">Runtime Environments</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_run_browser-txt.html">Runtime In The Browser</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_run_server-txt.html">Runtime On The Server</a></div></div><div class=MEntry><div class=MFile id=MSelected>Synchronization</div></div><div class=MEntry><div class=MFile><a href="junction-js.html">TrimPath.<span class=HB> </span>junction</a></div></div><div class=MEntry><div class=MFile><a href="junctionClient-js.html">TrimPath.<span class=HB> </span>junctionClient</a></div></div><div class=MEntry><div class=MFile><a href="junctionUtil-js.html">TrimPath.<span class=HB> </span>junctionUtil</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_controller-txt.html">web-MVC Controller</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_model-txt.html">web-MVC Model</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_view-txt.html">web-MVC View</a></div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent1')">Index</a><div class=MGroupContent id=MGroupContent1><div class=MEntry><div class=MIndex><a href="../index/General.html">Everything</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Classes.html">Classes</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Functions.html">Functions</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Variables.html">Variables</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Properties.html">Properties</a></div></div></div></div></div><!--END_ND_MENU--></td>

<td class=ContentSection valign=top><div class=CGeneric id=MainTopic><div class=CTopic><h1 class=CTitle><a name="Synchronization"></a>Synchronization</h1><div class=CBody><p class=CParagraph>The Junction synchronization system provides several basic services to propagate and handle...</p><ul class=CBulletList><li>Codebase updates</li><li>Database schema updates or migrations</li><li>Database record-level replication</li></ul><h4 class=CHeading>simpleSync</h4><p class=CParagraph>The protocol Junction implements is called &lsquo;simpleSync&rsquo;.&nbsp;  Its design is focused around a database-to-database level of synchronization, at the record level.&nbsp;  Other protocols, in contrast, might focus on recording and synchronizing higher-level command objects, or REST actions, or harmonizing file deltas, or reordering insert/delete commands, or some other concept, with different pros and cons to each kind of synchronization.</p><p class=CParagraph>Just as the saying goes with distributed objects, &lsquo;there is no location transparency&rsquo;, perhaps we can also say with distributed databases, &lsquo;there is no synchronization transparency&rsquo;.&nbsp;  Application developers need be aware of how simpleSync works, and how it can affect their designs, data models, and code.</p><h4 class=CHeading>Sync Request Initiation</h4><p class=CParagraph>A synchronization request is initiated by the client web-browser.&nbsp; This is due to the usage of the HTTP protocol, where a web-server cannot initiate requests.</p><p class=CParagraph>As part of the sync request, the Junction client transmits...</p><ul class=CBulletList><li>its current application version,</li><li>its unique client-side database id (or &lsquo;ident&rsquo;),</li><li>its last sync request timestamp</li><li>a delta of records that have changed in the client-side database since the last sync.</li></ul><h4 class=CHeading>Database Identity (or ident)</h4><p class=CParagraph>On the database ident, each database in the Junction world is assigned a unique numeric identifier, or &lsquo;ident&rsquo;.&nbsp;  For example, eacg server-side RDBMS in a team space for a particular application has a unique ident.&nbsp;  On the client-side, each Google Gears RDBMS database will be assigned a unique ident.&nbsp;  Each time a memory-database is created by the client-side Junction system, a unique ident is assigned.</p><p class=CParagraph>Junction uses a current datetime plus random number to generate these unique database ident&rsquo;s.</p><h4 class=CHeading>Codebase Updates</h4><p class=CParagraph>In response to the sync request, the first thing the Junction server checks is that the client or requestor is running the latest or same version of application code that exists on the server.</p><p class=CParagraph>The Junction server uses the last-modified timestamp of the application code directory as the application&rsquo;s version number.&nbsp; Developers should be careful to update or &lsquo;touch&rsquo; the code directory&rsquo;s last-modified timestamp whenever the application&rsquo;s codebase changes, to force existing clients to receive new code updates.&nbsp;  Pernicious bugs might seem to appear if you forget to do a &lsquo;touch&rsquo;.</p><p class=CParagraph>If the client is running outdated code, the Junction server thus sends a response with a complete copy of the entire, latest application codebase.</p><p class=CParagraph>The client-side Junction system uses that entire, complete copy of the application codebase to &lsquo;wipe out&rsquo; its old codebase, replacing it with the new application codebase.&nbsp;  Even if you change only a single line of code in the application, this simple protocol always transmits the entire, complete application codebase to the client in response to a codebase update.</p><h4 class=CHeading>Database Schema Updates or Migrations</h4><p class=CParagraph>In the complete application codebase that the client receives, besides the web-MVC code, the client also receives database schema migration scripts.&nbsp;  These are the *.js files that live under the db/migrate directory.&nbsp;  The client-side Junction system executes these scripts to ensure its local client-side RDBMS is updated to the same schema version as the server-side RDBMS.</p><p class=CParagraph>At this point, the client-side Junction system should be running the same version of application code and database schema as the server, so the client-side Junction system tries to initiate another sync request.</p><h4 class=CHeading>Database Record-Level Replication</h4><p class=CParagraph>When the Junction server receives a sync request, it first checks that the client or requestor is running the correct version of application code and schema.&nbsp;  If the versions match what the server is running, the server proceeds in processing the delta of records that were sent by the client.</p><p class=CParagraph>The delta of records includes any table rows that were inserted, updated or deleted since the last the the client sync&rsquo;ed.</p><h4 class=CHeading>Tracking Columns</h4><p class=CParagraph>The Junction system uses special database tables and columns to help the client RDBMS track which records were changed since the last sync.&nbsp;  These special database columns are automatically created by the Junction system if you used the Junction API of createStandardTable() in your database migration scripts.&nbsp;  These special tracking columns include...</p><blockquote><pre class=CCode>- id          integer primary key autoincrement<br>- created_at  datetime<br>- updated_at  datetime<br>- active      integer<br>- version     integer<br>- id_start    integer<br>- id_start_db varchar(40)<br>- synced_at   datetime</pre></blockquote><p class=CParagraph>The created_at and updated_at columns are automatically filled and updated by the Junction system whenever you call the Model.newInstance() and save() method of a Model instance.</p><p class=CParagraph>The version number column is automatically incremented, also, whenever you call the save() method of a Model instance.</p><h4 class=CHeading>The id column</h4><p class=CParagraph>Records are assigned permanent, positive id numbers by the server-side RDBMS.&nbsp;  If the application code is executed on the Junction SSWAS (server-side web application server), getting a new positive id number from the server-side RDBMS is easy.</p><p class=CParagraph>On the client-side Junction system, however, when a record is first created, the Junction client system does directly not request a new positive id number from the server.&nbsp;  Instead, the client-side Junction system just immediately assigns a &lsquo;unique&rsquo; negative id number to the record, where the negative id number is unique to the local database only.&nbsp;  The client-side Junction system tracks a monotonically decreasing negative id number on a per-database manner, so it can do fast negative-number id assignment.</p><h4 class=CHeading>The id_start and id_start_db columns</h4><p class=CParagraph>When a record is created, the Junction system also fills in the id_start column with a copy of the record&rsquo;s id number.&nbsp; If created on the client-side, then, both id and id_start will be a negative number.&nbsp;  If created on the server-side, both id and id_start will be positive.</p><p class=CParagraph>Also, the Junction system fills in the id_start_db column with the local database ident.</p><p class=CParagraph>This information helps Junction track who created the record, and helps Junction map from negative id&rsquo;s to positive id&rsquo;s (when they&rsquo;re assigned later) and vice-versa, from postitive id&rsquo;s to negative.</p><p class=CParagraph>The id_start and id_start_db columns are only assigned during record creation.</p><h4 class=CHeading>Record Delta Tracking Via Model</h4><p class=CParagraph>When running on the client-side, Junction watches object-relational Model calls for when new records are created.&nbsp;  For example, when you call invoice.save(), Junction remembers that a record in the Invoice table was either inserted/created or updated.&nbsp;  That record is then a candidate for synchronization on the next syncUp() call.</p><p class=CParagraph>However, if you directly call INSERT, UPDATE, or DELETE via direct SQL statments against the database rather than going through the object-relational Model API, Junction will not detect that direct SQL records have been changed.&nbsp;  Thus, such records will not be synchronized.</p><p class=CParagraph>Record delta tracking is not performed for the server-side Junction system, as the server-side RDBMS is considered the source of truth, and never outdated.</p><h4 class=CHeading>The active column, the active pattern, and handling DELETE&rsquo;s</h4><p class=CParagraph>There is one scenario, however, where not tracking server-side record deltas is an issue, and that is with respect to record DELETE&rsquo;s.&nbsp; Once a record is DELETE&rsquo;d from an RDBMS, it&rsquo;s gone.&nbsp;  In the scenario where we DELETE a record from the server-side RDBMS, and at a later time a client requests a synchronization, the server could mistakenly <b>not</b> inform the client that a record was DELETE&rsquo;d, because DELETE&rsquo;d records do not appear in any query results anymore.</p><p class=CParagraph>To solve this scenario, Junction recommends using the active flag column, and deactivating records instead of physically DELETE&rsquo;ing them.&nbsp;  Deactivating a record is just setting its active column value to 0.&nbsp;  An active record has an active column value of 1.&nbsp; Junction provides Model API&rsquo;s such as deactivate(), and findActive() to help developers code to the active flag column pattern.</p><p class=CParagraph>Instead of calling Invoice.find(...), developers should prefer calling Invoice.findActive(...), with the same parameters.&nbsp; The findActive() method adds the additional WHERE query clause of &lsquo; AND active = 1&rsquo; to any query it executes.</p><p class=CParagraph>Instead of calling invoice.destroy(), which performs a physical SQL DELETE, the developer should call invoice.deactivate(), which sets the active column value to 0 on the invoice record and save()&rsquo;s the invoice record.&nbsp;  During the save() call, the updated_at column and version colunn of the record are automatically updated, per normal Junction behavior.&nbsp;  To the synchronization system, thus, setting the active column value to 0 is just another record update that needs to be synchronized, and is handled through normal replication steps as described on this page.</p><p class=CParagraph>At a later time, after enough time has passed for the deactivation (setting active to 0) of a record has replicated to the server-side RDBMS and to all client RDBMS, then the record can be physically DELETE&rsquo;d or purged.&nbsp;  For example, just DELETE all records whose active = 0 and udpated_at is very long ago, according to application needs.</p><p class=CParagraph>Using the deactivation pattern, too, instead of true DELETE&rsquo;s, has the potential benefit of supporting undo features easier to implement.</p><h4 class=CHeading>Synchronized Tables Conventions</h4><p class=CParagraph>To be a candiated for synchronization, a table must follow some naming and design conventions.&nbsp;  The table must not have the suffix of &lsquo;Local&rsquo;.&nbsp;  For example, PreferenceLocal or ScratchTempLocal are two tables which will not be synchronized or replicated by Junction.</p><p class=CParagraph>Also, a table must have the tracking columns as described previously.</p><h4 class=CHeading>The db/sync.json file</h4><p class=CParagraph>By default, Junction synchronizes all records in all tables.&nbsp; While this is a useful default for faster initial development and prototyping of simple applications, Junction also provides a way to override this naive policy via the optional code/db/sync.json file.&nbsp;  Each application has its own code/db/sync.json file, and hence, ther own potential synchronization policy.</p><p class=CParagraph>The file format for the code/db/sync.json file is JSON.&nbsp; For example:</p><blockquote><pre class=CCode>{<br>  clientDbCache: {<br>    general : {<br>      Action  : &quot;WHERE (active = 1 AND completed_at IS NULL) OR (updated_at &gt;= date('now', '-1 month'))&quot;,<br>      Context : true,<br>      Project : true<br>    }<br>  }<br>}</pre></blockquote><p class=CParagraph>In it, an application developer can specify a subset of the main server-side database that is cachable by client web-browsers.&nbsp;  This is done by specifying a WHERE clause string per table, or the value of true to specify that the entire table should be cached on the client.</p><p class=CParagraph>Above, both the Context and Project tables will be cached in their entirety in the client-side RDBMS.</p><p class=CParagraph>And, the Active table will have only those records cached in the client-side that are current active and not yet completed, OR who have been updated within the last month.</p><p class=CParagraph>As part generating the synchronization response, Junction uses the above code/db/sync.json file information to run queries against the server-side RDBMS, to construct which records need to be sent to the client as part of the synchronization reply.</p><h4 class=CHeading>The synced_at column</h4><p class=CParagraph>The synced_at column is changed only by the Junction synchronization system, whenever a record delta is accepted by the server-side Junction system.&nbsp;  Also, the synced_at column holds the timestamp of the server-side system, and might be more recent than the updated_at column value of a record.&nbsp;  This might happen, for instance, when a record is changed by an offline client.&nbsp; So, the record&rsquo;s updated_at column is changed to time T.&nbsp; Later, then record is sent as part of a delta of records in a sync request to the server.&nbsp;  The Junction server updates the server-side RDBMS with the record delta, and updates the synced_at column of the record.&nbsp;  At this point, the updated_at value is still T, but the synced_at value is T+1.&nbsp;  Furthermore, the Junction system might include the record as part of the sync response message to any client.&nbsp;  As a client receives and processes the response message, it updates its local client-side RDBMS with the record information, which has updated_at value of T and synced_at value of T+1.</p><p class=CParagraph>The client-side Junction system also remembers its last time of receiving a sync reply message, for use when it sends its next sync request message in the future.</p><p class=CParagraph>The synced_at column is queried by the Junction synchronization system to limit the response it will send to clients.&nbsp;  That is, Junction appends an SQL WHERE AND clause of synced_at &gt;= [last sync request timestamp] to the query it uses to construct which reply records will be sent to the client.</p><h4 class=CHeading>Assumptions</h4><p class=CParagraph>The Junction simpleSync protocol makes several assumptions for it to work...</p><ul class=CBulletList><li>friendly, cooperative clients and servers (no liars)</li><li>monotonically decreasing negative temporary id numbers</li><li>db identity (ident) uniqueness</li><li>synchronized clocks, or correct clock time on computers</li></ul></div></div></div>

</td>

</tr></table><div class=Footer><!--START_ND_FOOTER-->Generated by <a href="http://www.naturaldocs.org">Natural Docs</a><!--END_ND_FOOTER--></div>
<!--START_ND_TOOLTIPS-->
<!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>